{"ast":null,"code":"import Autolinker from 'autolinker'; // Autoconvert URL-like texts to links\n\nvar LINK_SCAN_RE = /www|@|\\:\\/\\//;\n\nfunction isLinkOpen(str) {\n  return /^<a[>\\s]/i.test(str);\n}\n\nfunction isLinkClose(str) {\n  return /^<\\/a\\s*>/i.test(str);\n} // Stupid fabric to avoid singletons, for thread safety.\n// Required for engines like Nashorn.\n//\n\n\nfunction createLinkifier() {\n  var links = [];\n  var autolinker = new Autolinker({\n    stripPrefix: false,\n    url: true,\n    email: true,\n    replaceFn: function (match) {\n      // Only collect matched strings but don't change anything.\n      switch (match.getType()) {\n        /*eslint default-case:0*/\n        case 'url':\n          links.push({\n            text: match.matchedText,\n            url: match.getUrl()\n          });\n          break;\n\n        case 'email':\n          links.push({\n            text: match.matchedText,\n            // normalize email protocol\n            url: 'mailto:' + match.getEmail().replace(/^mailto:/i, '')\n          });\n          break;\n      }\n\n      return false;\n    }\n  });\n  return {\n    links: links,\n    autolinker: autolinker\n  };\n}\n\nfunction parseTokens(state) {\n  var i,\n      j,\n      l,\n      tokens,\n      token,\n      text,\n      nodes,\n      ln,\n      pos,\n      level,\n      htmlLinkLevel,\n      blockTokens = state.tokens,\n      linkifier = null,\n      links,\n      autolinker;\n\n  for (j = 0, l = blockTokens.length; j < l; j++) {\n    if (blockTokens[j].type !== 'inline') {\n      continue;\n    }\n\n    tokens = blockTokens[j].children;\n    htmlLinkLevel = 0; // We scan from the end, to keep position when new tags added.\n    // Use reversed logic in links start/end match\n\n    for (i = tokens.length - 1; i >= 0; i--) {\n      token = tokens[i]; // Skip content of markdown links\n\n      if (token.type === 'link_close') {\n        i--;\n\n        while (tokens[i].level !== token.level && tokens[i].type !== 'link_open') {\n          i--;\n        }\n\n        continue;\n      } // Skip content of html tag links\n\n\n      if (token.type === 'htmltag') {\n        if (isLinkOpen(token.content) && htmlLinkLevel > 0) {\n          htmlLinkLevel--;\n        }\n\n        if (isLinkClose(token.content)) {\n          htmlLinkLevel++;\n        }\n      }\n\n      if (htmlLinkLevel > 0) {\n        continue;\n      }\n\n      if (token.type === 'text' && LINK_SCAN_RE.test(token.content)) {\n        // Init linkifier in lazy manner, only if required.\n        if (!linkifier) {\n          linkifier = createLinkifier();\n          links = linkifier.links;\n          autolinker = linkifier.autolinker;\n        }\n\n        text = token.content;\n        links.length = 0;\n        autolinker.link(text);\n\n        if (!links.length) {\n          continue;\n        } // Now split string to nodes\n\n\n        nodes = [];\n        level = token.level;\n\n        for (ln = 0; ln < links.length; ln++) {\n          if (!state.inline.validateLink(links[ln].url)) {\n            continue;\n          }\n\n          pos = text.indexOf(links[ln].text);\n\n          if (pos) {\n            nodes.push({\n              type: 'text',\n              content: text.slice(0, pos),\n              level: level\n            });\n          }\n\n          nodes.push({\n            type: 'link_open',\n            href: links[ln].url,\n            title: '',\n            level: level++\n          });\n          nodes.push({\n            type: 'text',\n            content: links[ln].text,\n            level: level\n          });\n          nodes.push({\n            type: 'link_close',\n            level: --level\n          });\n          text = text.slice(pos + links[ln].text.length);\n        }\n\n        if (text.length) {\n          nodes.push({\n            type: 'text',\n            content: text,\n            level: level\n          });\n        } // replace current node\n\n\n        blockTokens[j].children = tokens = [].concat(tokens.slice(0, i), nodes, tokens.slice(i + 1));\n      }\n    }\n  }\n}\n\nfunction linkify(md) {\n  md.core.ruler.push('linkify', parseTokens);\n}\n\nexport { linkify };","map":{"version":3,"sources":["/Users/ashishsolanki/Documents/GitHub/editor.io/node_modules/remarkable/dist/esm/linkify.js"],"names":["Autolinker","LINK_SCAN_RE","isLinkOpen","str","test","isLinkClose","createLinkifier","links","autolinker","stripPrefix","url","email","replaceFn","match","getType","push","text","matchedText","getUrl","getEmail","replace","parseTokens","state","i","j","l","tokens","token","nodes","ln","pos","level","htmlLinkLevel","blockTokens","linkifier","length","type","children","content","link","inline","validateLink","indexOf","slice","href","title","concat","linkify","md","core","ruler"],"mappings":"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","sourcesContent":["import Autolinker from 'autolinker';\n\n// Autoconvert URL-like texts to links\n\n\nvar LINK_SCAN_RE = /www|@|\\:\\/\\//;\n\n\nfunction isLinkOpen(str) {\n  return /^<a[>\\s]/i.test(str);\n}\nfunction isLinkClose(str) {\n  return /^<\\/a\\s*>/i.test(str);\n}\n\n// Stupid fabric to avoid singletons, for thread safety.\n// Required for engines like Nashorn.\n//\nfunction createLinkifier() {\n  var links = [];\n  var autolinker = new Autolinker({\n    stripPrefix: false,\n    url: true,\n    email: true,\n    replaceFn: function (match) {\n      // Only collect matched strings but don't change anything.\n      switch (match.getType()) {\n        /*eslint default-case:0*/\n        case 'url':\n          links.push({\n            text: match.matchedText,\n            url: match.getUrl()\n          });\n          break;\n        case 'email':\n          links.push({\n            text: match.matchedText,\n            // normalize email protocol\n            url: 'mailto:' + match.getEmail().replace(/^mailto:/i, '')\n          });\n          break;\n      }\n      return false;\n    }\n  });\n\n  return {\n    links: links,\n    autolinker: autolinker\n  };\n}\n\n\nfunction parseTokens(state) {\n  var i, j, l, tokens, token, text, nodes, ln, pos, level, htmlLinkLevel,\n      blockTokens = state.tokens,\n      linkifier = null, links, autolinker;\n\n  for (j = 0, l = blockTokens.length; j < l; j++) {\n    if (blockTokens[j].type !== 'inline') { continue; }\n    tokens = blockTokens[j].children;\n\n    htmlLinkLevel = 0;\n\n    // We scan from the end, to keep position when new tags added.\n    // Use reversed logic in links start/end match\n    for (i = tokens.length - 1; i >= 0; i--) {\n      token = tokens[i];\n\n      // Skip content of markdown links\n      if (token.type === 'link_close') {\n        i--;\n        while (tokens[i].level !== token.level && tokens[i].type !== 'link_open') {\n          i--;\n        }\n        continue;\n      }\n\n      // Skip content of html tag links\n      if (token.type === 'htmltag') {\n        if (isLinkOpen(token.content) && htmlLinkLevel > 0) {\n          htmlLinkLevel--;\n        }\n        if (isLinkClose(token.content)) {\n          htmlLinkLevel++;\n        }\n      }\n      if (htmlLinkLevel > 0) { continue; }\n\n      if (token.type === 'text' && LINK_SCAN_RE.test(token.content)) {\n\n        // Init linkifier in lazy manner, only if required.\n        if (!linkifier) {\n          linkifier = createLinkifier();\n          links = linkifier.links;\n          autolinker = linkifier.autolinker;\n        }\n\n        text = token.content;\n        links.length = 0;\n        autolinker.link(text);\n\n        if (!links.length) { continue; }\n\n        // Now split string to nodes\n        nodes = [];\n        level = token.level;\n\n        for (ln = 0; ln < links.length; ln++) {\n\n          if (!state.inline.validateLink(links[ln].url)) { continue; }\n\n          pos = text.indexOf(links[ln].text);\n\n          if (pos) {\n            nodes.push({\n              type: 'text',\n              content: text.slice(0, pos),\n              level: level\n            });\n          }\n          nodes.push({\n            type: 'link_open',\n            href: links[ln].url,\n            title: '',\n            level: level++\n          });\n          nodes.push({\n            type: 'text',\n            content: links[ln].text,\n            level: level\n          });\n          nodes.push({\n            type: 'link_close',\n            level: --level\n          });\n          text = text.slice(pos + links[ln].text.length);\n        }\n        if (text.length) {\n          nodes.push({\n            type: 'text',\n            content: text,\n            level: level\n          });\n        }\n\n        // replace current node\n        blockTokens[j].children = tokens = [].concat(tokens.slice(0, i), nodes, tokens.slice(i + 1));\n      }\n    }\n  }\n}\nfunction linkify(md) {\n  md.core.ruler.push('linkify', parseTokens);\n}\n\nexport { linkify };\n"]},"metadata":{},"sourceType":"module"}